- [[READ UNCOMMITTED (RU)]] - 딴 놈 작업 중인 일도 훔쳐 본다
-
- [[READ COMMITTED (RC)]] - 확정된 것만 보는데, 다시 보면 달라 질 수 있음
	- 조회 · 통계 · 리스트
	- 읽기 90%
	-
- [[REPEATABLE READ (RR)]] - 확정 된 것 들 중, 내가 작업 중인 것은 끝까지 가져가는데, 새 것이 끼어들 수 있음.
	- 돈 · 재고 · 쿠폰
	- 쓰기 비중 높음
	-
- [[SERIALIZABLE (SR)]] - 모든 트랜잭션을 통제한다.
- ---
- ### 핵심
	- 상황에 맞는 설정 필요
	- **@Transactional + 격리 수준 설정 + 락 전략**을 함께 사용해야 제대로 작동함.
	- 실무에서는 격리 수준과 락만으로 안 될 땐 **DB 제약 조건, 멱등 처리, 중복 방지 토큰**까지 종합적으로 써야 함.
- ---
- ### 낙관적 락(Optimistic Lock)
	- **철학**:  "웬만하면 충돌 안 나니까 그냥 진행하고, 나중에 문제가 생기면 그때 처리하자."
	- **작동 원리**
		- 트랜잭션 동안 **락을 걸지 않음**.
		- 커밋 직전에, 이 데이터가 **다른 트랜잭션에 의해 수정되지 않았는지 검사**함.
	-
		- **방법 1: 버전 필드 사용**
			- 테이블에 `version` 컬럼 추가함.
			- 수정할 때 `WHERE id = ? AND version = ?` 조건을 붙임.
			- 성공하면 `version`을 +1 증가시킴. 실패하면 예외 발생 → 재시도.
		- **방법 2: 조건부 업데이트**
			- ```
			  UPDATE stock SET count = count - 1 WHERE id = 1 AND count > 0;
			  ```
			- 조건이 맞는 경우에만 업데이트되므로, 충돌을 피해감.
	-
	- **장점**
		- 락을 걸지 않아 **TPS(초당 처리량)가 높음**.
		- Deadlock 위험 없음.
	- **단점**
		- 충돌 시 재시도가 필요해 **성능이 불안정할 수 있음**.
		- 충돌이 잦은 환경에서는 오히려 비효율적일 수 있음.
	-
	- **적용 예시**
		- **데이터 충돌이 드문 경우** (ex: 마이페이지 수정, 프로필 업데이트)
		- **분산 시스템이나 서버가 여러 대일 때** (DB 락만으로 관리 어려움)
- ---
- ### 비관적 락(Pessimistic Lock)
	- **철학**: "충돌이 일어날 가능성이 있다면, 미리 잠그고 안전하게 작업하자."
	- **작동 방식**
		- 트랜잭션 시작 시, 필요한 데이터에 **배타 락을 먼저 걸고 시작**함.
		- 다른 트랜잭션은 락이 해제될 때까지 해당 데이터에 접근 불가.
	- **SQL 예시**
		- ```
		  SELECT * FROM stock WHERE id = 1 FOR UPDATE;
		  ```
		- 이 쿼리를 실행하면 `id = 1`인 행에 배타 락이 걸림.
	- **ORM 예시**
		- ```
		  @Lock(PESSIMISTIC_WRITE)
		  Member findById(Long id);
		  ```
	-
	- **장점**
		- 데이터 충돌 가능성이 완전히 차단됨.
		- 동시 수정 시에도 안전하게 순차 처리 가능.
	- **단점**
		- 락 대기 시간으로 인해 전체 처리 속도가 느려질 수 있음.
		- [[DeadLock (교착 상태)]] 발생 확률이 높아짐.
	-
	- **적용 예시**
		- 상품 재고 감소, 좌석 예약, 포인트 차감 등 **서로 동시에 처리되면 안 되는 경우**.
		- 특히 선착순이나 한정 수량 처리 로직에 적합함.
- ---
- ### 예방 및 대처
	- **락 순서 일관되게 잡기**
	  logseq.order-list-type:: number
		- 모든 트랜잭션이 동일한 순서로 자원을 요청하도록 설계.
		  logseq.order-list-type:: number
		- 예: "항상 사용자 → 상품 순으로 조회/수정"
		  logseq.order-list-type:: number
	- **트랜잭션을 최대한 짧게 유지**
	  logseq.order-list-type:: number
		- 처리 로직은 빠르게 끝내고, 외부 API 요청은 트랜잭션 밖으로 뺌.
		  logseq.order-list-type:: number
	- **자동 재시도 로직 구현**
	  logseq.order-list-type:: number
		- Java: `@Retryable`
		  logseq.order-list-type:: number
		- 충돌 시 n회까지 재 시도하고, 계속 실패하면 사용자에게 알림.
		  logseq.order-list-type:: number
	- **DB 타임아웃 짧게 설정하기**
	  logseq.order-list-type:: number
		- MySQL: `innodb_lock_wait_timeout`
		  logseq.order-list-type:: number
		- PostgreSQL: `lock_timeout`
		  logseq.order-list-type:: number
		- 일정 시간 지나면 에러로 돌리고 다음 트랜잭션 수행.
		  logseq.order-list-type:: number
	- **문제 트랜잭션 모니터링**
	  logseq.order-list-type:: number
		- DB의 데드락 로그, 느린 쿼리 로그를 정기적으로 분석함.
		  logseq.order-list-type:: number
		- 문제가 반복되는 경우 쿼리 개선 또는 락 범위 조정.
		  logseq.order-list-type:: number
	- **락 전략 혼합 사용**
	  logseq.order-list-type:: number
		- 처음엔 낙관적 락으로 처리 → 충돌이 많아지면 비관적으로 전환.
		  logseq.order-list-type:: number
			- 충돌이 자주 일어난다는 판단 -> 처음부터 비관적 락 사용
			  logseq.order-list-type:: number
		- 리소스 별로 전략을 달리함 (예: 주문 = 비관적, 리뷰 작성 = 낙관적)
		  logseq.order-list-type:: number
		- TPS(초당 처리량)가 중요하나?
		  logseq.order-list-type:: number
			- 그렇다면 **낙관적 락**을 기본으로 쓰고, 충돌은 재시도로 대응함.
			  logseq.order-list-type:: number
		- 서버가 여러 대인가? (분산 환경)
		  logseq.order-list-type:: number
			- 단일 DB 락만으론 부족함 → **Redis Redlock** 같은 분산 락 도입 고려함.
			  logseq.order-list-type:: number
		- 실시간 장애나 지연이 발생하고 있나?
		  logseq.order-list-type:: number
			- 데드락 로그, 응답 지연 로그를 기반으로 **락 전략을 조정**해야 함.
			  logseq.order-list-type:: number
			- logseq.order-list-type:: number
	- 실제로는 한 가지 전략만 쓰지 않고, 비관적 + 낙관적 혼합, 또는 락 + DB 무결성 제약 + 캐시까지 함께 고려해야 실무에 적합한 구조가 됨.
- ---
-